var fs = require('fs-extra'),
    path = require('path'),
    du = require('du'),
    globby = require('globby'),
    Q = require('q'),
    targets = require('./targets'),
    cli = require('./cli');


function parseIgnoreFile(ignoreFile) {
    return Q

        .nfcall(fs.ensureFile, ignoreFile.path)

        .then(function () {
            return Q.nfcall(fs.readFile, ignoreFile.path);
        })

        .then(function (content) {
            //NOTE: yep, so selfish...
            ignoreFile.content = content.toString() ||
                                 '# Generated by dmn (https://github.com/inikulin/dmn)';

            ignoreFile.patterns = ignoreFile.content
                .replace(/\r\n?/g, '\n')
                .split('\n')
                .map(function (str) {
                    return str.trim();
                })
                .filter(function (str) {
                    //NOTE: remove empty strings and comments
                    return str && str.indexOf('#') !== 0;
                });
        });
}

function isUniquePattern(pattern, ignoreFile) {
    //NOTE: skip duplicate patterns and patterns which should not be ignored
    return ignoreFile.patterns.indexOf(pattern) === -1 &&
           ignoreFile.patterns.indexOf('!' + pattern) === -1;
}

function getPatternFilter(ignoreFile) {
    return function (pattern) {
        if (!isUniquePattern(pattern, ignoreFile))
            return false;

        //NOTE: if we have trailing slash check if we have matches without it
        if (pattern[pattern.length - 1] === '/') {
            var unslashed = pattern.substring(0, pattern.length - 1);

            return isUniquePattern(unslashed, ignoreFile);
        }

        return true;
    };
}

function findPatternsToAdd(projectDir, ignoreFile) {
    var patternsToAdd = [];

    var globPromises = targets.map(function (pattern) {
        return Q

            //NOTE: try filter
            .nfcall(globby, pattern, {cwd: projectDir})

            .then(function (files) {
                if (files.length)
                    patternsToAdd.push(pattern);
            });
    });

    return Q

        .all(globPromises)

        .then(function () {
            return patternsToAdd

                .filter(getPatternFilter(ignoreFile))

                //NOTE: since Win FS is case insensitive we will have duplicate patterns
                //which differ only by case (e.g. 'Gulpfile.js' and 'gulpfile.js').
                //There is no simple way to get actual case of filename on Windows,
                //so we just include both matches. It will lead to additional entry if
                //.npmignore if it was generated on Win, but this approach is safe in
                //terms of cross-platform use. We just will try to make things beatiful.
                //Let's make patterns which differ only by case grouped. For this we sort twice.
                //First sort is required to get the right order (upper case first) in the group.
                //Second pass is case-insensitive and produces groups.
                .sort()
                .sort(function (pattern1, pattern2) {
                    pattern1 = pattern1.toLowerCase();
                    pattern2 = pattern2.toLowerCase();

                    if (pattern1 === pattern2)
                        return 0;

                    return pattern1 > pattern2 ? 1 : -1;
                });
        });
}

function savePatterns(ignoreFile, patternsToAdd) {
    ignoreFile.content += '\r\n\r\n' + patternsToAdd.join('\r\n');

    return Q

        .nfcall(fs.writeFile, ignoreFile.path, ignoreFile.content)

        .then(function () {
            cli.ok('.npmignore file was updated.');

            return 'OK: saved';
        });
}

function confirmSave(ignoreFile, patternsToAdd) {
    return Q

        .Promise(function (done) {
            cli.confirm('Save?', done);
        })

        .then(function (yes) {
            if (yes)
                return savePatterns(ignoreFile, patternsToAdd);

            cli.ok('.npmignore file update was canceled.');

            return 'OK: canceled';
        });
}

//API
module.exports = function (projectDir, options) {
    var ignoreFile = {
        path: path.join(projectDir, './.npmignore'),
        content: '',
        patterns: []
    };

    cli.info('Searching for items to add to .npmignore file...').spin();

    return parseIgnoreFile(ignoreFile)

        .then(function () {
            return findPatternsToAdd(projectDir, ignoreFile);
        })

        .then(function (patternsToAdd) {
            if (!patternsToAdd.length) {
                cli.ok('Unignored patterns was not found. Your .npmignore file is already perfect.');

                return 'OK: already-perfect';
            }

            cli.info('Following patterns will be added to .npmignore file:');
            cli.list(patternsToAdd);

            if (options.force)
                return savePatterns(ignoreFile, patternsToAdd);

            return confirmSave(ignoreFile, patternsToAdd);
        });
};

