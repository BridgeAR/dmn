var fs = require('fs-extra'),
    path = require('path'),
    du = require('du'),
    globby = require('globby'),
    Q = require('q'),
    targets = require('./targets'),
    cli = require('./cli');


//Utils
function exit() {
    setTimeout(process.exit);
}


function parseIgnoreFile(ignoreFile) {
    return Q

        .nfcall(fs.ensureFile, ignoreFile)

        .then(function () {
            return Q.nfcall(fs.readFile, ignoreFile);
        })

        .then(function (content) {
            content = content.toString();

            //NOTE: yep, so selfish...
            content = content || '# Generated by dmn (https://github.com/inikulin/dmn)';

            var patterns = content
                .replace(/\r\n?/g, '\n')
                .split('\n')
                .map(function (str) {
                    return str.trim();
                })
                .filter(function (str) {
                    //NOTE: remove empty strings and comments
                    return str && str.indexOf('#') !== 0;
                });

            return Q({
                content: content,
                patterns: patterns
            });
        });
}

function findPatternsToAdd(projectDir, npmignore) {
    var patternsToAdd = [];

    var globPromises = targets.map(function (pattern) {
        return Q

            .nfcall(globby, pattern, {cwd: projectDir})

            .then(function (files) {
                if (files.length)
                    patternsToAdd.push(pattern);
            });
    });

    return Q

        .all(globPromises)

        .then(function () {
            //NOTE: skip already ignored patterns and patterns which should not be ignored
            patternsToAdd = patternsToAdd.filter(function (pattern) {
                return npmignore.patterns.indexOf(pattern) === -1 &&
                       npmignore.patterns.indexOf('!' + pattern) === -1;
            });

            return Q([npmignore, patternsToAdd]);
        });
}

function savePatterns(ignoreFile, npmignore, patternsToAdd) {
    npmignore.content += '\r\n\r\n' + patternsToAdd.join('\r\n');

    return Q

        .nfcall(fs.writeFile, ignoreFile, npmignore.content)

        .then(function () {
            cli.ok('.npmignore file was updated.');

            return Q('saved');
        });
}

function confirmSave(ignoreFile, npmignore, patternsToAdd) {
    return Q

        .Promise(function (done) {
            cli.confirm('Save?', done);
        })

        .then(function (yes) {
            if (yes)
                return savePatterns(ignoreFile, npmignore, patternsToAdd);

            cli.ok('.npmignore file update was canceled.');

            return  Q('canceled');
        });
}

//API
module.exports = function (projectDir, options) {
    var ignoreFile = path.join(projectDir, './.npmignore');

    cli.info('Analyzing project...').spin();

    return parseIgnoreFile(ignoreFile)

        .then(function (npmignore) {
            return findPatternsToAdd(projectDir, npmignore);
        })

        .spread(function (npmignore, patternsToAdd) {
            if (!patternsToAdd.length) {
                cli.ok('Unignored patterns was not found. Your .npmignore file is already perfect.');

                return Q('already-perfect');
            }

            cli.info('Following patterns will be added to .npmignore file:');
            cli.list(patternsToAdd);

            if (options.force)
                return savePatterns(ignoreFile, npmignore, patternsToAdd);

            return confirmSave(ignoreFile, npmignore, patternsToAdd);
        });
};

